<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1279348640476088"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-format="fluid"
     data-ad-layout-key="-6t+ed+2i-1n-4w"
     data-ad-client="ca-pub-1279348640476088"
     data-ad-slot="6150167225"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>


<div id="test-button" style="background: red; color: white; padding: 10px; text-align: center; cursor: pointer; margin: 20px 0;" onclick="alert('테스트 버튼이 클릭되었습니다!')">테스트 버튼 - 클릭해보세요</div>

<script>
// 두 h2 요소 사이의 정가운데 클릭 함수
function clickBetweenH2s() {
    try {
        console.log('두 H2 사이 클릭 함수 실행됨');
        
        const allH2s = document.querySelectorAll('h2');
        console.log('찾은 h2 요소 개수:', allH2s.length);
        
        if (allH2s.length >= 2) {
            const firstH2 = allH2s[0];
            const secondH2 = allH2s[1];
            
            const firstRect = firstH2.getBoundingClientRect();
            const secondRect = secondH2.getBoundingClientRect();
            
            console.log('첫 번째 H2 위치:', firstRect);
            console.log('두 번째 H2 위치:', secondRect);
            
            // 더 정확한 중심점 계산 - 첫 번째 h2의 하단과 두 번째 h2의 상단 사이
            const centerX = window.innerWidth / 2; // 화면 가로 중앙
            const centerY = firstRect.bottom + (secondRect.top - firstRect.bottom) / 2;
            
            console.log('두 H2 사이 중심 좌표:', centerX, centerY);
            
            // 여러 위치에서 시도
            const positions = [
                {x: centerX, y: centerY},
                {x: centerX - 50, y: centerY},
                {x: centerX + 50, y: centerY},
                {x: centerX, y: centerY - 20},
                {x: centerX, y: centerY + 20}
            ];
            
            for (let pos of positions) {
                const targetElement = document.elementFromPoint(pos.x, pos.y);
                console.log(`위치 (${pos.x}, ${pos.y})에서 찾은 요소:`, targetElement);
                
                // 테스트 버튼이나 다른 요소 클릭 시도
                if (targetElement) {
                    console.log('요소 클릭 시도:', targetElement.tagName, targetElement.className, targetElement.id);
                    
                    // iframe인 경우 더 강력한 클릭 시도
                    if (targetElement.tagName === 'IFRAME' && targetElement.id === 'aswift_1') {
                        console.log('AdSense iframe 발견! 강력한 클릭 시도');
                        
                        // 1. 직접 클릭
                        targetElement.click();
                        
                        // 2. 포커스 후 클릭
                        try {
                            targetElement.focus();
                            targetElement.click();
                        } catch(e) { console.log('포커스 실패:', e); }
                        
                        // 3. 다양한 마우스 이벤트 발생
                        const events = ['mousedown', 'mouseup', 'click'];
                        events.forEach(eventType => {
                            const event = new MouseEvent(eventType, {
                                bubbles: true,
                                cancelable: true,
                                view: window,
                                clientX: pos.x,
                                clientY: pos.y,
                                button: 0,
                                buttons: 1
                            });
                            targetElement.dispatchEvent(event);
                            console.log(`${eventType} 이벤트 발생`);
                        });
                        
                        // 4. 포인터 이벤트도 시도
                        try {
                            const pointerEvent = new PointerEvent('click', {
                                bubbles: true,
                                cancelable: true,
                                pointerId: 1,
                                clientX: pos.x,
                                clientY: pos.y
                            });
                            targetElement.dispatchEvent(pointerEvent);
                            console.log('포인터 클릭 이벤트 발생');
                        } catch(e) { console.log('포인터 이벤트 실패:', e); }
                        
                        break;
                    }
                    
                    // 테스트 버튼 클릭
                    if (targetElement.id === 'test-button' || targetElement.closest('#test-button')) {
                        console.log('테스트 버튼 클릭!');
                        targetElement.click();
                        break;
                    }
                    
                    // 일반 요소 클릭
                    if (targetElement.tagName !== 'HTML' && targetElement.tagName !== 'BODY') {
                        console.log('일반 요소 클릭 시도:', targetElement);
                        targetElement.click();
                        break;
                    }
                }
            }
        }
    } catch (e) {
        console.log('클릭 함수 오류:', e);
    }
}

// 실행 횟수 제한
let clickCount = 0;
const maxClicks = 5;

function executeClick() {
    if (clickCount < maxClicks) {
        clickCount++;
        clickBetweenH2s();
    }
}

// 페이지 로딩 후 실행
window.addEventListener('load', function() {
    console.log('페이지 로드 완료');
    // AdSense 광고가 로드될 시간을 충분히 기다림
    setTimeout(executeClick, 3000);
    
    // 추가 시도들
    setTimeout(executeClick, 5000);
    setTimeout(executeClick, 7000);
});

// 사용자 상호작용 처리 함수
function handleUserInteraction(eventType, e) {
    console.log(`사용자 ${eventType} 상호작용 감지!`, e.target);
    if (clickCount < maxClicks) {
        console.log('클릭 카운트:', clickCount, '최대:', maxClicks);
        setTimeout(executeClick, 100);
    } else {
        console.log('최대 클릭 횟수에 도달했습니다.');
    }
}

// 다양한 사용자 상호작용 이벤트 감지
document.addEventListener('click', function(e) {
    handleUserInteraction('클릭', e);
});

document.addEventListener('mousemove', function(e) {
    // mousemove는 너무 자주 발생하므로 throttle 적용
    if (!window.mouseMoveThrottle) {
        window.mouseMoveThrottle = true;
        handleUserInteraction('마우스 이동', e);
        setTimeout(() => {
            window.mouseMoveThrottle = false;
        }, 1000); // 1초마다 한 번만 실행
    }
});

document.addEventListener('scroll', function(e) {
    // scroll도 너무 자주 발생하므로 throttle 적용
    if (!window.scrollThrottle) {
        window.scrollThrottle = true;
        handleUserInteraction('스크롤', e);
        setTimeout(() => {
            window.scrollThrottle = false;
        }, 1000);
    }
});

document.addEventListener('keydown', function(e) {
    handleUserInteraction('키 입력', e);
});

// 추가 디버깅을 위한 다른 이벤트들
document.addEventListener('mousedown', function(e) {
    console.log('마우스 다운 감지:', e.target);
});

document.addEventListener('mouseup', function(e) {
    console.log('마우스 업 감지:', e.target);
});
</script>
